import re

from django import get_version
from django.db.migrations.writer import MigrationWriter
from django.utils.timezone import now


class EncryptMigrationWriter(MigrationWriter):
    def __init__(self, model, fields=None, *args, **kwargs):
        self.model = model
        self.fields = fields or []
        super().__init__(*args, **kwargs)

    def as_string(self):
        """Return a string of the file contents."""
        items = {
            "replaces_str": "",
            "initial_str": "",
        }

        imports = set()

        # Format dependencies and write out swappable dependencies right
        dependencies = []
        for dependency in self.migration.dependencies:
            if dependency[0] == "__setting__":
                dependencies.append(
                    "        migrations.swappable_dependency(settings.%s),"
                    % dependency[1]
                )
                imports.add("from django.conf import settings")
            else:
                dependencies.append("        %s," % self.serialize(dependency)[0])
        items["dependencies"] = "\n".join(dependencies) + "\n" if dependencies else ""

        items["app_label"] = self.model._meta.app_label
        items["model"] = self.model._meta.object_name

        # Format imports nicely, swapping imports of functions from migration files
        # for comments
        migration_imports = set()
        for line in list(imports):
            if re.match(r"^import (.*)\.\d+[^\s]*$", line):
                migration_imports.add(line.split("import")[1].strip())
                imports.remove(line)
                self.needs_manual_porting = True

        # django.db.migrations is always used, but models import may not be.
        # If models import exists, merge it with migrations import.
        if "from django.db import models" in imports:
            imports.discard("from django.db import models")
            imports.add("from django.db import migrations, models")
        else:
            imports.add("from django.db import migrations")

        # Sort imports by the package / module to be imported (the part after
        # "from" in "from ... import ..." or after "import" in "import ...").
        sorted_imports = sorted(imports, key=lambda i: i.split()[1])
        items["imports"] = "\n".join(sorted_imports) + "\n" if imports else ""
        if migration_imports:
            items["imports"] += (
                "\n\n# Functions from the following migrations need manual "
                "copying.\n# Move them and any dependencies into this file, "
                "then update the\n# RunPython operations to refer to the local "
                "versions:\n# %s"
            ) % "\n# ".join(sorted(migration_imports))
        # If there's a replaces, make a string for it
        if self.migration.replaces:
            items["replaces_str"] = (
                "\n    replaces = %s\n" % self.serialize(self.migration.replaces)[0]
            )
        # Hinting that goes into comment
        if self.include_header:
            items["migration_header"] = MIGRATION_HEADER_TEMPLATE % {
                "version": get_version(),
                "timestamp": now().strftime("%Y-%m-%d %H:%M"),
            }
        else:
            items["migration_header"] = ""

        if self.migration.initial:
            items["initial_str"] = "\n    initial = True\n"

        items["fields"] = self.describe_fields()

        return MIGRATION_TEMPLATE % items

    def describe_fields(self):
        encryptable_fields = self.encryptable_fields()

        descriptions = []
        if not self.fields:
            descriptions.append("    # TODO: uncomment or remove lines below")
        for field in encryptable_fields:
            deconstructed = field.deconstruct()
            deconstructed[3].pop("null", None)
            descriptions.append(
                f"    {'# ' if not self.fields else ''}{deconstructed + (field.null,)!r}"
            )

        return "\n".join(descriptions)

    def encryptable_fields(self):
        return (
            self.model._meta._get_fields(include_parents=False, reverse=False)
            if not self.fields
            else [self.model._meta.get_field(field) for field in self.fields]
        )


MIGRATION_HEADER_TEMPLATE = """\
# Generated by django-gdpr on Django %(version)s on %(timestamp)s

"""

MIGRATION_TEMPLATE = """\
%(migration_header)s%(imports)s

################
app_with_model = '%(app_label)s'
model_with_column = '%(model)s'
fields_to_encrypt = [
%(fields)s
]
################


def forwards_encrypt_field(field_name):
    def inner(apps, schema_editor):
        Model = apps.get_model(app_with_model, model_with_column)
        for row in Model.objects.all():
            setattr(row, field_name, getattr(row, f'{field_name}_old', None))
            row.save(update_fields=[field_name])

    return inner


def reverse_encrypt_field(field_name):
    def inner(apps, schema_editor):
        Model = apps.get_model(app_with_model, model_with_column)
        for row in Model.objects.all():
            setattr(row, f'{field_name}_old', getattr(row, field_name, None))
            row.save(update_fields=[f'{field_name}_old'])

    return inner


class Migration(migrations.Migration):
%(replaces_str)s%(initial_str)s
    dependencies = [
%(dependencies)s\
    ]

    operations = chain(*[
        [
            # Rename current field to 'old'
            migrations.RenameField(
                model_name=model_with_column.lower(),
                old_name=column_to_encrypt,
                new_name=f'{column_to_encrypt}_old',
            ),

            # Make old field nullable, if it was not nullable. This helps the reverse migration.
            migrations.AlterField(
                model_name=model_with_column.lower(),
                name=f'{column_to_encrypt}_old',
                field=field_class(*args, **kwargs, null=True),
            ) if not nullable else migrations.RunPython(migrations.RunPython.noop, migrations.RunPython.noop),

            # Add the new encrypted column, initially nullable.
            migrations.AddField(
                model_name=model_with_column.lower(),
                name=column_to_encrypt,
                field=encrypt(field_class(*args, **kwargs, null=True)),
            ),

            # Copy data from old to new, encrypting in the process.
            migrations.RunPython(
                code=forwards_encrypt_field(column_to_encrypt),
                reverse_code=reverse_encrypt_field(column_to_encrypt),
            ),

            # Remove the old column. Note that the reverse migration will ADD the column, with NULL.
            migrations.RemoveField(
                model_name=model_with_column.lower(),
                name=f'{column_to_encrypt}_old',
            ),

            # Set null=False on the new column if the original column had null=True
            migrations.AlterField(
                model_name=model_with_column.lower(),
                name=column_to_encrypt,
                field=encrypt(field_class(*args, **kwargs, null=False)),
            ) if not nullable else migrations.RunPython(migrations.RunPython.noop, migrations.RunPython.noop),
        ]
        for (column_to_encrypt, field_class, args, kwargs, nullable)
        in fields_to_encrypt
    ])

"""
